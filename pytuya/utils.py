import base64
import sys
import logging
import time
import json
import colorsys
import re

try:
    # raise ImportError
    import Crypto
    from Crypto.Cipher import AES  # PyCrypto
except ImportError:
    Crypto = AES = None
    import pyaes  # https://github.com/ricmoo/pyaes

log = logging.getLogger(__name__)
logging.basicConfig()  # TODO include function name/line numbers in log
# log.setLevel(level=logging.DEBUG)  # Debug hack!

log.info('Python %s on %s', sys.version, sys.platform)
if Crypto is None:
    log.info('Using pyaes version %r', pyaes.VERSION)
    log.info('Using pyaes from %r', pyaes.__file__)
else:
    log.info('Using PyCrypto %r', Crypto.version_info)
    log.info('Using PyCrypto from %r', Crypto.__file__)

SET = 'set'

PROTOCOL_VERSION_BYTES = b'3.1'

IS_PY2 = sys.version_info[0] == 2


class AESCipher(object):
    def __init__(self, key):
        self.bs = 16
        self.key = key

    def encrypt(self, raw):
        if Crypto:
            raw = self._pad(raw)
            cipher = AES.new(self.key, mode=AES.MODE_ECB)
            crypted_text = cipher.encrypt(raw)
        else:
            _ = self._pad(raw)
            cipher = pyaes.blockfeeder.Encrypter(pyaes.AESModeOfOperationECB(self.key))  # no IV, auto pads to 16
            crypted_text = cipher.feed(raw)
            crypted_text += cipher.feed()  # flush final block
        crypted_text_b64 = base64.b64encode(crypted_text)
        return crypted_text_b64

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        if Crypto:
            cipher = AES.new(self.key, AES.MODE_ECB)
            raw = cipher.decrypt(enc)
            return self._unpad(raw).decode('utf-8')
        else:
            cipher = pyaes.blockfeeder.Decrypter(pyaes.AESModeOfOperationECB(self.key))  # no IV, auto pads to 16
            plain_text = cipher.feed(enc)
            plain_text += cipher.feed()  # flush final block
            return plain_text

    def _pad(self, s):
        padnum = self.bs - len(s) % self.bs
        return s + padnum * chr(padnum).encode()

    @staticmethod
    def _unpad(s):
        return s[:-ord(s[len(s) - 1:])]


def bin2hex(x, pretty=False):
    space = ' ' if pretty else ''
    if IS_PY2:
        x = [ord(xi) for xi in x]

    return ''.join('%02X%s' % (y, space) for y in x)


def hex2bin(x):
    if IS_PY2:
        return x.decode('hex')
    else:
        return bytes.fromhex(x)


class Colour:
    @staticmethod
    def rgb_to_hex_value(r, g, b):
        """ Convert an RGB value to the hex representation expected by tuya.

        Index '5' (DPS_INDEX_COLOUR) is assumed to be in the format:
        rrggbb0hhhssvv

        While r, g and b are just hexadecimal values of the corresponding
        Red, Green and Blue values, the h, s and v values (which are values
        between 0 and 1) are scaled to 360 (h) and 255 (s and v) respectively.

        Args:
            r(int): Value for the colour red as int from 0-255.
            g(int): Value for the colour green as int from 0-255.
            b(int): Value for the colour blue as int from 0-255.
        """
        rgb = [r, g, b]
        hsv = colorsys.rgb_to_hsv(rgb[0] / 255, rgb[1] / 255, rgb[2] / 255)

        hex_value = ""
        for value in rgb:
            temp = str(hex(int(value))).replace("0x", "")
            if len(temp) == 1:
                temp = "0" + temp
            hex_value = hex_value + temp

        hsvarray = [int(hsv[0] * 360), int(hsv[1] * 255), int(hsv[2] * 255)]
        hex_value_hsv = ""
        for value in hsvarray:
            temp = str(hex(int(value))).replace("0x", "")
            if len(temp) == 1:
                temp = "0" + temp
            hex_value_hsv = hex_value_hsv + temp
        if len(hex_value_hsv) == 7:
            hex_value = hex_value + "0" + hex_value_hsv
        else:
            hex_value = hex_value + "00" + hex_value_hsv

        return hex_value

    @staticmethod
    def hex_value_to_rgb(hex_value):
        """
        Converts the hex_value used by tuya for colour representation into an RGB value.

        Args:
            hex_value(string): The hex representation generated by Color.rgb_to_hex_value()
        """
        r = int(hex_value[0:2], 16)
        g = int(hex_value[2:4], 16)
        b = int(hex_value[4:6], 16)
        return r, g, b

    @staticmethod
    def hex_value_to_hsv(hex_value):
        """
        Converts the hex_value used by tuya for colour representation into an HSV value.

        Args:
            hex_value(string): The hex representation generated by rgb_to_hex_value()
        """
        h = int(hex_value[7:10], 16) / 360
        s = int(hex_value[10:12], 16) / 255
        v = int(hex_value[12:14], 16) / 255

        return h, s, v


def query_devices(timeout_in_s=3.1, max_count=None):
    from socket import socket, AF_INET, SOCK_DGRAM

    def decode_message(message):
        json_msg = message[message.index(b"{"):-message[::-1].index(b"}")]
        try:
            return json.loads(json_msg)
        except json.JSONDecodeError as e:
            logging.warning("Error occurred while trying to decode json message: %s", e)
            return {}

    s = socket(AF_INET, SOCK_DGRAM)
    s.bind(('', 6666))
    s.settimeout(timeout_in_s)

    guids = {}
    t_start = time.time()
    while time.time() < t_start + timeout_in_s:
        message = s.recv(1024)
        data = decode_message(message)
        if data.get("gwId") not in guids:
            guids[data.get("gwId")] = data
        if max_count and len(guids) == max_count:
            break

    return guids


class KeyExtractor:
    # extracts device ids and corresponding local keys from a server api response
    # which can be obtained by sniffing app traffic (e.g. using ssl capture app). see howto for details.
    # local keys are necessary to send commands to devices

    @staticmethod
    def get_device_keys_hacky(api_response):
        api_response = str(api_response)

        def get_json_value(key, json_str):
            matches = re.findall("\"%s\":\"([a-zA-Z0-9\ -]*)\"" % key, json_str, re.DOTALL)
            return matches[0] if len(matches) > 0 else None

        keys = {}

        # split api result by devId entry and extract next found localKey entry as corresponding key
        #  CAREFULLY NOTE: this assumes the devId entry always comes BEFORE the localKey entry in the dictionary
        for dev_result in api_response.split("devId")[1:]:
            dev_id = dev_result[dev_result.index(":") + 2:dev_result.index("\",")]
            key = get_json_value("localKey", dev_result)
            if key is None:
                logging.warning("no key found for entry with id %s" % dev_id)
                continue

            name = get_json_value("name", dev_result)
            keys[dev_id] = dict(key=key, name=name, id=dev_id)

        return keys

    @staticmethod
    def get_device_keys_json(api_response):
        data = json.loads(api_response)
        keys = {}
        for entry in data.get("result", []):
            if entry.get('a') == 'tuya.m.my.group.device.list':
                for dev in entry.get('result'):
                    if 'devId' in dev:
                        keys[dev['devId']] = dict(key=dev['localKey'], name=dev.get("name", ""), id=dev['devId'])
            if 'devId' in entry:
                dev = entry
                keys[dev['devId']] = dict(key=dev['localKey'], name=dev.get("name", ""), id=dev['devId'])
        return keys

    @staticmethod
    def parse_device_keys_from_api_response(api_response):
        try:
            keys = KeyExtractor.get_device_keys_json(api_response)
        except Exception as e:
            logging.info("getting device keys using json method failed: \n\t%s\ntrying hacky method instead.." % e)
            keys = KeyExtractor.get_device_keys_hacky(api_response)
        return keys
